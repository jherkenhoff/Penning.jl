var documenterSearchIndex = {"docs":
[{"location":"simulation/distributed_parallel/","page":"Distributed / parallel computing","title":"Distributed / parallel computing","text":"N_threads","category":"page"},{"location":"simulation/distributed_parallel/","page":"Distributed / parallel computing","title":"Distributed / parallel computing","text":"Threads for individual particles","category":"page"},{"location":"simulation/distributed_parallel/","page":"Distributed / parallel computing","title":"Distributed / parallel computing","text":"Example:","category":"page"},{"location":"simulation/distributed_parallel/","page":"Distributed / parallel computing","title":"Distributed / parallel computing","text":"Trap 1 |- Particle collection 1 (N=20) |- Particle collection 2 (N=20)\nTrap 2 |- Particle collection 3 (N=300)","category":"page"},{"location":"simulation_setup/particles/#Particles","page":"Particles","title":"Particles","text":"","category":"section"},{"location":"simulation_setup/particles/#Particle-collection","page":"Particles","title":"Particle collection","text":"","category":"section"},{"location":"simulation_setup/particles/","page":"Particles","title":"Particles","text":"In Penning.jl, equally behaving particles are contained in a ParticleCollection","category":"page"},{"location":"simulation_setup/particles/","page":"Particles","title":"Particles","text":"ParticleCollection","category":"page"},{"location":"simulation_setup/particles/#Penning.Particles.ParticleCollection","page":"Particles","title":"Penning.Particles.ParticleCollection","text":"Fields:\n\nspecies: Instance of type Species, specifying the type (charge and mass) of particles in this collection\nr: Position of the particles in this collection\nv: Velocities of the particles in this collection\nE: Used to store the electric field at the positions of the individual particles during simulation\nE: Used to store the magnetic field at the positions of the individual particles during simulation\ndamping: 3-dimensional vector specifying an artificial damping constant for all particles in this collection\n\n\n\n\n\n","category":"type"},{"location":"simulation_setup/particles/#Species","page":"Particles","title":"Species","text":"","category":"section"},{"location":"simulation_setup/particles/","page":"Particles","title":"Particles","text":"Species\nElectron()\nIon(::Number, ::Number)","category":"page"},{"location":"simulation_setup/particles/#Penning.Particles.Species","page":"Particles","title":"Penning.Particles.Species","text":"Species\n\nParameter object for spcifying the mass m (in kg) and the charge q (in C) of a particle species.\n\n\n\n\n\n","category":"type"},{"location":"simulation_setup/particles/#Penning.Particles.Electron-Tuple{}","page":"Particles","title":"Penning.Particles.Electron","text":"Electron()\n\nPredefined particle species for the electron\n\n\n\n\n\n","category":"method"},{"location":"simulation_setup/particles/#Penning.Particles.Ion-Tuple{Number, Number}","page":"Particles","title":"Penning.Particles.Ion","text":"Ion(m, q)\n\nFunction for generating a particle species using units commonly used in atomic physics: Mass m is provided in atomic mass units and charge q is provided in units of (positive) elementary charge.\n\nExample:\n\nThe following instantiates an ion with mass 187 u and charge state 28+\n\nmy_ion = Ion(187, 28)\n\n\n\n\n\n","category":"method"},{"location":"simulation_setup/particles/","page":"Particles","title":"Particles","text":"","category":"page"},{"location":"simulation_setup/particles/#Particle-disttributions","page":"Particles","title":"Particle disttributions","text":"","category":"section"},{"location":"generated/basic_eigenmotion/","page":"Basic eigenmotion","title":"Basic eigenmotion","text":"EditURL = \"https://github.com/jherkenhoff/Penning.jl/blob/main/examples/basic_eigenmotion.jl\"","category":"page"},{"location":"generated/basic_eigenmotion/","page":"Basic eigenmotion","title":"Basic eigenmotion","text":"using Penning\nusing Plots\n\nconst N_AXIAL_CYCLES = 10\nconst OVERSAMPLING = 20\n\nconst U₀ = -50.0\nconst c₂ = -14960.0\nconst B₀ = 7.0\n\nRe_ions = ParticleCollection(Ion(187, 30), [[0, 0, 0.5]], [[1000, 0, 0]])\n\nomega_p = calc_omega_p(U₀, c₂, B₀, Re_ions.species.q, Re_ions.species.m)\nomega_z = calc_omega_z(U₀, c₂, B₀, Re_ions.species.q, Re_ions.species.m)\n\ntrap = Trap(\n    fields = (\n        IdealTrapField(U₀, c₂, B₀),\n    ),\n    particles = (\n        Re_ions,\n    )\n)\n\nsetup = Setup(\n    traps = (\n        trap,\n    )\n)\n\ndt = 2*pi/omega_p/OVERSAMPLING\nsim = Simulation(\n    setup,\n    dt=dt,\n    output_writers=(\n        MemoryWriter(PositionComponentObservable(1, 1, 1, 3), IterationInterval(1)),\n    )\n)\n\nrun!(sim, run_until_time=2*pi/omega_z*N_AXIAL_CYCLES)\n\nz = sim.output_writers[1].mem\nt = sim.output_writers[1].t\n\nplot(t, z)","category":"page"},{"location":"generated/basic_eigenmotion/","page":"Basic eigenmotion","title":"Basic eigenmotion","text":"","category":"page"},{"location":"generated/basic_eigenmotion/","page":"Basic eigenmotion","title":"Basic eigenmotion","text":"This page was generated using Literate.jl.","category":"page"},{"location":"simulation_setup/traps/#Traps","page":"Traps","title":"Traps","text":"","category":"section"},{"location":"simulation_setup/traps/#Custom-traps","page":"Traps","title":"Custom traps","text":"","category":"section"},{"location":"simulation_setup/traps/","page":"Traps","title":"Traps","text":"You might want to simulate the effects of fluctuating trap potentials or drifting magnetic fields.","category":"page"},{"location":"getting_started/#Getting-started","page":"Getting Started","title":"Getting started","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This section covers the basics of installing Julia and Oceananigans, and then describes best practices when running Oceananigans. If you're new to Julia, we also recommend reading Julia's \"getting started\" page.","category":"page"},{"location":"getting_started/#Installation-instructions","page":"Getting Started","title":"Installation instructions","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Usually the hardest part of installing Oceananigans is installing Julia. You can first check if your system already has Julia installed. If that's not the case, installation is necessary and you can download Julia from its official website, where also you can find platform-specific installation instructions. Alternatively, you can also manually compile Julia from source code.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"With Julia installed, you can install Oceananigans with a single line of code within Julia itself: ] add Oceananigans.  However, best practices for Julia suggest a couple extra commands to ensure that each project has a separate and easily reproducible environment (we suggest that users read this page to get a better understanding of working with environments). Best practices when starting a new Oceananigans  project is to ","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Start with a empty directory (in this example called new_project).\nInside the empty directory, start Julia with the command julia --project.\nAccess the built-in package manager by pressing ] in the Julia command prompt.\nAdd the Oceananigans package with add Oceananigans.\nInstantiate/build all dependencies instantiate.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"To do so, open a Julia REPL from the terminal and then start the package manager by hitting ]. Then:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"(@v1.6) pkg> activate .\n  Activating new environment at `~/new_project/Project.toml`\n\n(new_project) pkg> add Oceananigans\n(new_project) pkg> instantiate","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"We recommend installing Oceananigans with this way (using the built-in Julia package manager), because this installs a stable, tagged release. Oceananigans.jl can be updated to the latest tagged release from the package manager by typing","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"(new_project) pkg> update Oceananigans","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"At this time, updating should be done with care, as Oceananigans is under rapid development and breaking  changes to the user API occur often. But if anything does happen, please open an issue on github! We're more than happy to help with getting your simulations up and running.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"compat: Julia 1.6 or newer\nThe latest version of Oceananigans requires at least Julia v1.6 to run. Installing Oceananigans with an older version of Julia will install an older version of Oceananigans (the latest version compatible with your version of Julia).","category":"page"},{"location":"getting_started/#Running-Oceananigans","page":"Getting Started","title":"Running Oceananigans","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Whenever you run Oceananigans for a project, it is recommended that you activate the project's environment first. This ensures that you will always use the package versions of you project and that any changes there will not affect other projects.. To activate the project's environment you either start Julia using julia --project or from Julia's package manager you call:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"(@v1.6) pkg> activate .\n  Activating new project at `~/new_project`\n\n(new_project) pkg>","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"For initial explorations and getting used to the code, you can enter the commands directly in the Julia REPL (which can be started with the command julia --project). The REPL is an interactive command-line tool (similar to Python's IPython) that has a searchable history, tab-completion, helpful keybindings, and many other features to help users interact with packages. If you already have a script, you can call julia --project my_oceananigans_script.jl from the terminal. This will execute all the commands in that script and subsequently close Julia. This is equivalent to opening the Julia REPL inside your project directory and typing each of those commands by hand (or simply calling include(\"my_oceananigans_script.jl\") in the REPL).","category":"page"},{"location":"output_writers/memory_writer/#Writing-to-memory","page":"Writing to memory","title":"Writing to memory","text":"","category":"section"},{"location":"output_writers/memory_writer/","page":"Writing to memory","title":"Writing to memory","text":"In many cases, it might be helpful to keep a \"history\" of certain variables of a simulation inside the main memory (RAM). This allows to perform data analysis in Julia right after finishing the simulation, without having to store the data in an intermediate file on disk (which might also slow down your simulation).","category":"page"},{"location":"output_writers/memory_writer/","page":"Writing to memory","title":"Writing to memory","text":"info: Info\nWhen executing long running simulations or storing big chunks of data per write-iteration, you might want to keep an eye on memory utilization.","category":"page"},{"location":"output_writers/memory_writer/#MemoryWriter","page":"Writing to memory","title":"MemoryWriter","text":"","category":"section"},{"location":"output_writers/memory_writer/","page":"Writing to memory","title":"Writing to memory","text":"MemoryWriter(::Function, ::Penning.OutputWriters.Utils.AbstractSchedule)","category":"page"},{"location":"output_writers/memory_writer/#PositionMemoryWriter","page":"Writing to memory","title":"PositionMemoryWriter","text":"","category":"section"},{"location":"output_writers/memory_writer/","page":"Writing to memory","title":"Writing to memory","text":"PositionMemoryWriter(::Symbol, ::Symbol, ::Penning.Utils.AbstractSchedule)","category":"page"},{"location":"output_writers/memory_writer/#CircuitMemoryWriter","page":"Writing to memory","title":"CircuitMemoryWriter","text":"","category":"section"},{"location":"output_writers/memory_writer/","page":"Writing to memory","title":"Writing to memory","text":"CircuitMemoryWriter(observable, ::Penning.Utils.AbstractSchedule)","category":"page"},{"location":"simulation_setup/interactions/#Particle-interactions","page":"Particle interactions","title":"Particle interactions","text":"","category":"section"},{"location":"utils/schedules/#Schedules","page":"Schedules","title":"Schedules","text":"","category":"section"},{"location":"utils/schedules/","page":"Schedules","title":"Schedules","text":"Various parts of Penning.jl (e.g. Output writers or callbacks) need to execute certain actions at specific time intervals. For that, a family of schedules were introduced that cover a variety of basic scheduling tasks:","category":"page"},{"location":"utils/schedules/","page":"Schedules","title":"Schedules","text":"TimeInterval\nAlignedTimeInterval\nIterationInterval\nWallTimeInterval\nSpecifiedTimes","category":"page"},{"location":"utils/schedules/","page":"Schedules","title":"Schedules","text":"Additionally, there are \"composit schedules\", that link different schedules together, to build complex time dependencies:","category":"page"},{"location":"utils/schedules/","page":"Schedules","title":"Schedules","text":"ConsecutiveIterations\nAndSchedule\nOrSchedule","category":"page"},{"location":"utils/schedules/#TimeInterval","page":"Schedules","title":"TimeInterval","text":"","category":"section"},{"location":"utils/schedules/","page":"Schedules","title":"Schedules","text":"TimeInterval(::Number)","category":"page"},{"location":"utils/schedules/#Penning.Utils.TimeInterval-Tuple{Number}","page":"Schedules","title":"Penning.Utils.TimeInterval","text":"TimeInterval(interval)\n\nReturns a callable TimeInterval that schedules periodic output or diagnostic evaluation on a interval of simulation time, as kept by model.clock. Pay attention that this schedule might not actuate in equidistant intervals if the passed interval is not properly  aligned with the simulation time step.  See AlignedTimeInterval for an aligned version.\n\n\n\n\n\n","category":"method"},{"location":"utils/schedules/#AlignedTimeInterval","page":"Schedules","title":"AlignedTimeInterval","text":"","category":"section"},{"location":"utils/schedules/","page":"Schedules","title":"Schedules","text":"AlignedTimeInterval(::Number, ::Number)","category":"page"},{"location":"utils/schedules/#Penning.Utils.AlignedTimeInterval-Tuple{Number, Number}","page":"Schedules","title":"Penning.Utils.AlignedTimeInterval","text":"AlignedTimeInterval(interval, dt)\n\nSimilar to TimeInterval, but aligns the passed interval to multiples of dt. Actually, this function returns an IterationInterval in order to guarantee for  exactly equidistant \"actuation events\".\n\n\n\n\n\n","category":"method"},{"location":"utils/schedules/#IterationInterval","page":"Schedules","title":"IterationInterval","text":"","category":"section"},{"location":"utils/schedules/","page":"Schedules","title":"Schedules","text":"IterationInterval(interval)","category":"page"},{"location":"utils/schedules/#Penning.Utils.IterationInterval-Tuple{Any}","page":"Schedules","title":"Penning.Utils.IterationInterval","text":"IterationInterval(interval; offset=0)\n\nReturns a callable IterationInterval that \"actuates\" whenever the simulation iteration (modified by offset) is a multiple of interval. For example, \n\nIterationInterval(100) actuates at iterations [100, 200, 300, ...].\nIterationInterval(100, offset=-1) actuates at iterations [99, 199, 299, ...].\n\n\n\n\n\n","category":"method"},{"location":"utils/schedules/#WallTimeInterval","page":"Schedules","title":"WallTimeInterval","text":"","category":"section"},{"location":"utils/schedules/","page":"Schedules","title":"Schedules","text":"WallTimeInterval(interval)","category":"page"},{"location":"utils/schedules/#Penning.Utils.WallTimeInterval-Tuple{Any}","page":"Schedules","title":"Penning.Utils.WallTimeInterval","text":"WallTimeInterval(interval; start_time = time_ns() * 1e-9)\n\nReturns a callable WallTimeInterval that actuates on a interval of \"wall time\" while a simulation runs, in units of seconds. The \"wall time\" is the actual real world time in seconds, as kept by an actual or hypothetical clock hanging on your wall. The keyword argument start_time can be used to specify a starting wall time other than the moment WallTimeInterval is constructed.\n\n\n\n\n\n","category":"method"},{"location":"utils/schedules/#SpecifiedTimes","page":"Schedules","title":"SpecifiedTimes","text":"","category":"section"},{"location":"utils/schedules/","page":"Schedules","title":"Schedules","text":"SpecifiedTimes(::Vararg{<:Number})","category":"page"},{"location":"utils/schedules/#Penning.Utils.SpecifiedTimes-Tuple{Vararg{Number}}","page":"Schedules","title":"Penning.Utils.SpecifiedTimes","text":"SpecifiedTimes(times)\n\nReturns a callable SpecifiedTimes that actuates at predefined simulation times. Pass times either by individual arguments SpecifiedTimes(0.0, 3.14, 8.9) or as a list SpecifiedTimes([0.0, 3.14, 8.9])\n\n\n\n\n\n","category":"method"},{"location":"utils/schedules/#ConsecutiveIterations","page":"Schedules","title":"ConsecutiveIterations","text":"","category":"section"},{"location":"utils/schedules/","page":"Schedules","title":"Schedules","text":"ConsecutiveIterations(parent_schedule)","category":"page"},{"location":"utils/schedules/#AndSchedule","page":"Schedules","title":"AndSchedule","text":"","category":"section"},{"location":"utils/schedules/","page":"Schedules","title":"Schedules","text":"AndSchedule(schedules...)","category":"page"},{"location":"utils/schedules/#Penning.Utils.AndSchedule-Tuple","page":"Schedules","title":"Penning.Utils.AndSchedule","text":"AndSchedule(child_schedule_1, child_schedule_2, other_child_schedules...)\n\nReturn a schedule that actuates when all child_schedules actuate.\n\n\n\n\n\n","category":"method"},{"location":"utils/schedules/#OrSchedule","page":"Schedules","title":"OrSchedule","text":"","category":"section"},{"location":"utils/schedules/","page":"Schedules","title":"Schedules","text":"OrSchedule(schedules...)","category":"page"},{"location":"utils/schedules/#Penning.Utils.OrSchedule-Tuple","page":"Schedules","title":"Penning.Utils.OrSchedule","text":"OrSchedule(child_schedule_1, child_schedule_2, other_child_schedules...)\n\nReturn a schedule that actuates when any of the child_schedules actuates.\n\n\n\n\n\n","category":"method"},{"location":"output_writers/overview/#Output-writers-overview","page":"Overview","title":"Output writers overview","text":"","category":"section"},{"location":"output_writers/overview/","page":"Overview","title":"Overview","text":"Penning.jl provides various output mechanisms that can be readily used to save the state or derived variables of a simulation.","category":"page"},{"location":"output_writers/overview/#Schedules","page":"Overview","title":"Schedules","text":"","category":"section"},{"location":"output_writers/overview/","page":"Overview","title":"Overview","text":"All output writers accept a schedule argument, which specifies at which point in time the output should be saved. The available schedule-implementations are defined in the Schedules documentation.","category":"page"},{"location":"output_writers/overview/#Registering-output-writers","page":"Overview","title":"Registering output writers","text":"","category":"section"},{"location":"output_writers/overview/","page":"Overview","title":"Overview","text":"In order for the output writers to be executed during the simulation, they must be registered to the Simulation instance:","category":"page"},{"location":"output_writers/overview/","page":"Overview","title":"Overview","text":"sim = Simulation(...)\nsim.output_writers[:electron_position] = PositionMemoryWriter(...)","category":"page"},{"location":"output_writers/overview/","page":"Overview","title":"Overview","text":"In this example the output writer was registered under the name/symbol :electron_position.","category":"page"},{"location":"#Penning.jl","page":"Home","title":"Penning.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Flexible and extensible Julia framework for simulating the motion of particles in Penning traps.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Penning.jl is a flexible and extensible simulation framework written in Julia that uses a symplectic time stepper to solve for the motion of charged particles in a Penning trap and features an integrated circuit simulator that is coupled to the Penning trap simulation. It scales from simple single-particle systems up to complex N-body problems, possibly in multiple interconnected Penning-traps. Penning.jl comes with many builtin features like a variety of excitation fields, including dipolar fields, plane waves and cavity modes, support for different damping mechanisms, noise injection and more. The integrated circuit simulator can be used to model the coupling of particles to a user-defined external circuit, most commonly an RLC tank circuit.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The interface was designed to make Penning.jl as friendly and intuitive to use as possible. An in-built collection of diagnostics and file-writers enables post-processing directly in Julia or 3rd party applications.","category":"page"},{"location":"simulation/integrators/#Particle-Integrators","page":"Particle integrators","title":"Particle Integrators","text":"","category":"section"},{"location":"simulation/integrators/","page":"Particle integrators","title":"Particle integrators","text":"Standard ODE solvers (e.g. 4th order Runge Kutta) add a small numerical error at each timestep, which, over the long run, leads to a drift of the total energy inside the system. This is particularly undesirable for particle simulations, as they are usually being run for many timesteps and would therefore be guaranteed to end up with unphysical particle trajectories. We therefore have to carefully choose a particle integration algorithm that conserves energy, e.g. one of the family of symplectic integrators. A very simple aproach for symplectic integration is the leap-frog scheme, in which particle positions and velocities are calculated in a time-staggered manner.","category":"page"},{"location":"simulation/integrators/#Boris-Method","page":"Particle integrators","title":"Boris Method","text":"","category":"section"},{"location":"simulation/integrators/#Modified-Boris-Method-(DEFAULT)","page":"Particle integrators","title":"Modified Boris Method (DEFAULT)","text":"","category":"section"},{"location":"simulation/integrators/","page":"Particle integrators","title":"Particle integrators","text":"While the Boris method is good at preserving conserved quantities, it introduces a phase error on the radial modes. However, there is a simple modification[1], that fixes the phase error in all orders for static magnetic fields. For spatially or time-varying magnetic fields this is not necessarily true, which has to be further evaluated. The modified Boris pusher is available as ModifiedBorisPusher in Penning and is used by default if no particle pusher is explicitly specified.","category":"page"}]
}
