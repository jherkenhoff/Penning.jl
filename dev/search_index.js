var documenterSearchIndex = {"docs":
[{"location":"simulation/distributed_parallel/","page":"Distributed / parallel computing","title":"Distributed / parallel computing","text":"N_threads","category":"page"},{"location":"simulation/distributed_parallel/","page":"Distributed / parallel computing","title":"Distributed / parallel computing","text":"Threads for individual particles","category":"page"},{"location":"simulation/distributed_parallel/","page":"Distributed / parallel computing","title":"Distributed / parallel computing","text":"Example:","category":"page"},{"location":"simulation/distributed_parallel/","page":"Distributed / parallel computing","title":"Distributed / parallel computing","text":"Trap 1 |- Particle collection 1 (N=20) |- Particle collection 2 (N=20)\nTrap 2 |- Particle collection 3 (N=300)","category":"page"},{"location":"simulation_setup/particles/#Particles","page":"Particles","title":"Particles","text":"","category":"section"},{"location":"simulation_setup/particles/#Particle-collection","page":"Particles","title":"Particle collection","text":"","category":"section"},{"location":"simulation_setup/particles/","page":"Particles","title":"Particles","text":"In Penning.jl, equally behaving particles are contained in a ParticleCollection","category":"page"},{"location":"simulation_setup/particles/","page":"Particles","title":"Particles","text":"ParticleCollection","category":"page"},{"location":"simulation_setup/particles/#Penning.Particles.ParticleCollection","page":"Particles","title":"Penning.Particles.ParticleCollection","text":"Fields:\n\nspecies: Instance of type Species, specifying the type (charge and mass) of particles in this collection\nr: Position of the particles in this collection\nv: Velocities of the particles in this collection\nE: Used to store the electric field at the positions of the individual particles during simulation\nE: Used to store the magnetic field at the positions of the individual particles during simulation\ndamping: 3-dimensional vector specifying an artificial damping constant for all particles in this collection\n\n\n\n\n\n","category":"type"},{"location":"simulation_setup/particles/#Species","page":"Particles","title":"Species","text":"","category":"section"},{"location":"simulation_setup/particles/","page":"Particles","title":"Particles","text":"Species\nElectron()\nIon(::Number, ::Number)","category":"page"},{"location":"simulation_setup/particles/#Penning.Particles.Species","page":"Particles","title":"Penning.Particles.Species","text":"Species\n\nParameter object for spcifying the mass m (in kg) and the charge q (in C) of a particle species.\n\n\n\n\n\n","category":"type"},{"location":"simulation_setup/particles/#Penning.Particles.Electron-Tuple{}","page":"Particles","title":"Penning.Particles.Electron","text":"Electron()\n\nPredefined particle species for the electron\n\n\n\n\n\n","category":"method"},{"location":"simulation_setup/particles/#Penning.Particles.Ion-Tuple{Number, Number}","page":"Particles","title":"Penning.Particles.Ion","text":"Ion(m, q)\n\nFunction for generating a particle species using units commonly used in atomic physics: Mass m is provided in atomic mass units and charge q is provided in units of (positive) elementary charge.\n\nExample:\n\nThe following instantiates an ion with mass 187 u and charge state 28+\n\nmy_ion = Ion(187, 28)\n\n\n\n\n\n","category":"method"},{"location":"simulation_setup/particles/","page":"Particles","title":"Particles","text":"","category":"page"},{"location":"simulation_setup/particles/#Particle-disttributions","page":"Particles","title":"Particle disttributions","text":"","category":"section"},{"location":"circuit_cosimulation/theory/#State-space-representation","page":"Theory","title":"State-space representation","text":"","category":"section"},{"location":"circuit_cosimulation/theory/","page":"Theory","title":"Theory","text":"In Penning.jl, circuits are implemented in state-space representation, which is a technique to describe and solve systems of differentials equations in the time domain.","category":"page"},{"location":"circuit_cosimulation/theory/#Theory","page":"Theory","title":"Theory","text":"","category":"section"},{"location":"circuit_cosimulation/theory/","page":"Theory","title":"Theory","text":"In general, electrical circuits can be described as a nth-order ordinary differential equation with n concentrated energy reservoirs. In state-space representation, this equation is decomposed into n 1st-order differential equations and put into a matrix/vector representation.","category":"page"},{"location":"circuit_cosimulation/theory/","page":"Theory","title":"Theory","text":"The state of such a system is fully described by the energy content of its n energy reservoirs, called the state variables. State variables are, for example, the voltage at a capacitor, the current in an inductor, in a spring-mass system the deflection of the spring or the velocity of the mass. In state-space representation the individual state variables are composed into a state vector x.","category":"page"},{"location":"circuit_cosimulation/theory/","page":"Theory","title":"Theory","text":"The behaviour of such a system is fully described by a set of system-matrices:","category":"page"},{"location":"circuit_cosimulation/theory/","page":"Theory","title":"Theory","text":"The state matrix mathbfA describes how the state vector changes depending on the current state vector\nThe input matrix mathbfB describes how the state vector changes depending on the current input vector\nThe output matrix mathbfC translates the current state vector into an output vector\nThe feedthrough matrix mathbfD translates the current input vector into an output vector","category":"page"},{"location":"circuit_cosimulation/theory/","page":"Theory","title":"Theory","text":"The inputs and outputs of a system modeled in state-space representation are encapsulated in the input and output vectors i and u. While in general, there are no restrictions on the physical units associated with the inputs and outputs, for Penning.jl they are fixed: The circuit-cosimulation functionality in Penning.jl is solely designed to calculate the voltages on an electrode that are resulting from image currents induced on a Penning trap electrode. Therefore, we want to model our circuit such that it takes a current as an input and outputs an associated voltage (which is why the input vector is named i and the output vector is named u). Care must be taken when a circuit provides multiple inputs and outputs (i.e. multiple pins, multiple connections to different electrodes). In that case, the current on the first input must correspond to the voltage on the first output, and so on. In sloppy mathematical notation, we could write this as","category":"page"},{"location":"circuit_cosimulation/theory/","page":"Theory","title":"Theory","text":"left beginarrayc\nu_textnormalelectrode1(t) \nu_textnormalelectrode2(t)\nendarray right\n = textnormalCircuitleft(left beginarrayc\ni_textnormalelectrode1(t) \ni_textnormalelectrode2(t)\nendarray rightright)","category":"page"},{"location":"circuit_cosimulation/theory/","page":"Theory","title":"Theory","text":"for a circuit accepting two electrode-connections.","category":"page"},{"location":"circuit_cosimulation/theory/","page":"Theory","title":"Theory","text":"The state-space representation is often visualized as a block diagram, showing the interplay between system-matrices and vectors:","category":"page"},{"location":"circuit_cosimulation/theory/","page":"Theory","title":"Theory","text":"(Image: )","category":"page"},{"location":"circuit_cosimulation/theory/","page":"Theory","title":"Theory","text":"It must be noted that the blocks labeled x_n and u_n do not comply with the common state-space representation, but are an extension for Penning.jl to model noise:","category":"page"},{"location":"circuit_cosimulation/theory/","page":"Theory","title":"Theory","text":"The vector x_n models noise that is added to the state vector\nThe vector u_n models noise that is added to the output vector","category":"page"},{"location":"circuit_cosimulation/theory/","page":"Theory","title":"Theory","text":"With all these definitions out of the way, the state-space representation can be algebraicly described using the state equation","category":"page"},{"location":"circuit_cosimulation/theory/","page":"Theory","title":"Theory","text":"dotmathbfx(t) = mathbfA(t) mathbfx(t) + mathbfB(t) mathbfi(t) + mathbfx_n(t)","category":"page"},{"location":"circuit_cosimulation/theory/","page":"Theory","title":"Theory","text":"and the output equation","category":"page"},{"location":"circuit_cosimulation/theory/","page":"Theory","title":"Theory","text":"mathbfu(t) = mathbfC(t) mathbfx(t) + mathbfD(t) mathbfi(t) + mathbfu_n(t)","category":"page"},{"location":"circuit_cosimulation/theory/#Example:-Resistor","page":"Theory","title":"Example: Resistor","text":"","category":"section"},{"location":"circuit_cosimulation/overview/#Circuit-cosimulation","page":"Overview","title":"Circuit cosimulation","text":"","category":"section"},{"location":"generated/examples/basic_eigenmotion/","page":"Basic eigenmotion","title":"Basic eigenmotion","text":"EditURL = \"https://github.com/jherkenhoff/Penning.jl/blob/main/examples/basic_eigenmotion.jl\"","category":"page"},{"location":"generated/examples/basic_eigenmotion/#Basic-eigenmotion-example","page":"Basic eigenmotion","title":"Basic eigenmotion example","text":"","category":"section"},{"location":"generated/examples/basic_eigenmotion/","page":"Basic eigenmotion","title":"Basic eigenmotion","text":"In this example, we are going to simulate the motion of a single ion stored inside a Penning trap. This example can be considered as the hello world of Penning.jl. You will learn how to:","category":"page"},{"location":"generated/examples/basic_eigenmotion/","page":"Basic eigenmotion","title":"Basic eigenmotion","text":"Set up a simple simulation with one ion in an ideal Penning trap\nStore simulation data (in this case the position of the ion) to memory\nAccess the simulation data\nPlot the simulated ion motion","category":"page"},{"location":"generated/examples/basic_eigenmotion/#Install-dependencies","page":"Basic eigenmotion","title":"Install dependencies","text":"","category":"section"},{"location":"generated/examples/basic_eigenmotion/","page":"Basic eigenmotion","title":"Basic eigenmotion","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"generated/examples/basic_eigenmotion/","page":"Basic eigenmotion","title":"Basic eigenmotion","text":"using Pkg\npkg\"add Penning, Plots\"","category":"page"},{"location":"generated/examples/basic_eigenmotion/#Import-dependencies","page":"Basic eigenmotion","title":"Import dependencies","text":"","category":"section"},{"location":"generated/examples/basic_eigenmotion/","page":"Basic eigenmotion","title":"Basic eigenmotion","text":"In order to use the functionality of Penning.jl, we have to tell Julia that we want to use this package. While we are at it, lets also import the Plots package:","category":"page"},{"location":"generated/examples/basic_eigenmotion/","page":"Basic eigenmotion","title":"Basic eigenmotion","text":"using Penning\nusing Plots","category":"page"},{"location":"generated/examples/basic_eigenmotion/#Define-trap-parameters","page":"Basic eigenmotion","title":"Define trap parameters","text":"","category":"section"},{"location":"generated/examples/basic_eigenmotion/","page":"Basic eigenmotion","title":"Basic eigenmotion","text":"Define some trap parameters for the ideal trap. As you can see, the names of the constants contain unicode characters, which are nice to read, but may seem hard to type at first glance. However, if you are a Julia developer, chances are high that you are using Visual Studio Code with the Julia extension, which makes typing unicode characters a breeze: You just have to type U\\_0 and hit enter or tab and VS Code will add the correct unicode symbol.","category":"page"},{"location":"generated/examples/basic_eigenmotion/","page":"Basic eigenmotion","title":"Basic eigenmotion","text":"const Uâ‚€ = -50.0\nconst câ‚‚ = -14960.0\nconst Bâ‚€ = 1.0","category":"page"},{"location":"generated/examples/basic_eigenmotion/#Instantiate-trap","page":"Basic eigenmotion","title":"Instantiate trap","text":"","category":"section"},{"location":"generated/examples/basic_eigenmotion/","page":"Basic eigenmotion","title":"Basic eigenmotion","text":"The Trap object contains all things related to a single Penning trap. In this example, we are using an IdealTrapField with the previously specified parameters. For more complex simulations, this is the place where you would also add for example excitation fields or field imperfections.","category":"page"},{"location":"generated/examples/basic_eigenmotion/","page":"Basic eigenmotion","title":"Basic eigenmotion","text":"Since an empty trap would be quite boring, we have to specify the particle species and initial positions and velocities of all particles contained in the simulation. Penning.jl groups particles of same particle species into ParticleCollections, which is a concept that becomes important if you want to specify and control inter-particle interactions. But since we only want to simulate a single ion we only need a single particle collection. In this example, we are using an ion with mass 187 u (atomic mass unit) and charge state 30 (in elementary charge unit). The initial position and velocity have to be specified in meters and meters per second.","category":"page"},{"location":"generated/examples/basic_eigenmotion/","page":"Basic eigenmotion","title":"Basic eigenmotion","text":"trap = Trap(\n    fields = (\n        IdealTrapField(Uâ‚€, câ‚‚, Bâ‚€),\n    ),\n    particles = (\n        ParticleCollection(Ion(187, 30), [[0, 0, 50e-6]], [[1000, 0, 0]]),\n    )\n)","category":"page"},{"location":"generated/examples/basic_eigenmotion/#Instantiate-setup","page":"Basic eigenmotion","title":"Instantiate setup","text":"","category":"section"},{"location":"generated/examples/basic_eigenmotion/","page":"Basic eigenmotion","title":"Basic eigenmotion","text":"The following code instantiates a Setup object, which contains all \"subsystems\" that should be included in this simulation setup. In this example, we only want to simulate our previously instantiated trap, but in more complex simulations this would be the place where you would for example add multiple traps, add electrical circuits and specify their connections.","category":"page"},{"location":"generated/examples/basic_eigenmotion/","page":"Basic eigenmotion","title":"Basic eigenmotion","text":"setup = Setup(\n    traps = (\n        trap,\n    )\n)","category":"page"},{"location":"generated/examples/basic_eigenmotion/#Instantiate-simulation-object","page":"Basic eigenmotion","title":"Instantiate simulation object","text":"","category":"section"},{"location":"generated/examples/basic_eigenmotion/","page":"Basic eigenmotion","title":"Basic eigenmotion","text":"The Simulation object contains a single reference to a Setup object and is otherwise responsible for  storing information about how the simulation is performed. Here, we specify that we want to use a time step (dt) of 20 ns and specify which data we want to save during simulation. In Penning.jl, data is stored using \"output writers\", which offers various \"data storage backends\". In this case we are using a MemoryWriter, which stores data into system memory (RAM).","category":"page"},{"location":"generated/examples/basic_eigenmotion/","page":"Basic eigenmotion","title":"Basic eigenmotion","text":"The code PositionObservable(1, 1, 1) tells our MemoryWriter that we want to store the position of the particle in trap 1, particle collection 1 and index 1. (Note that the first index in Julia is 1, not 0)","category":"page"},{"location":"generated/examples/basic_eigenmotion/","page":"Basic eigenmotion","title":"Basic eigenmotion","text":"The code IterationInterval(1) specifies the times at which the specified observable is to be saved. In this case, we want to store data at every simulation iteration.","category":"page"},{"location":"generated/examples/basic_eigenmotion/","page":"Basic eigenmotion","title":"Basic eigenmotion","text":"sim = Simulation(\n    setup,\n    dt=20e-9,\n    output_writers=(\n        MemoryWriter(PositionObservable(1, 1, 1), IterationInterval(1)),\n    )\n)","category":"page"},{"location":"generated/examples/basic_eigenmotion/#Run-simulation","page":"Basic eigenmotion","title":"Run simulation","text":"","category":"section"},{"location":"generated/examples/basic_eigenmotion/","page":"Basic eigenmotion","title":"Basic eigenmotion","text":"Its finally time to run the simulation! Just specify how long you want to simulate and lean back (but not for too long - Penning.jl is fast ðŸ˜‰). Take a look at the documentation of run! for further stop conditions.","category":"page"},{"location":"generated/examples/basic_eigenmotion/","page":"Basic eigenmotion","title":"Basic eigenmotion","text":"run!(sim, run_until_time=10e-6)","category":"page"},{"location":"generated/examples/basic_eigenmotion/#Retreive-simulation-data","page":"Basic eigenmotion","title":"Retreive simulation data","text":"","category":"section"},{"location":"generated/examples/basic_eigenmotion/","page":"Basic eigenmotion","title":"Basic eigenmotion","text":"Data stored inside a MemoryWriter can be accessed in the following way:","category":"page"},{"location":"generated/examples/basic_eigenmotion/","page":"Basic eigenmotion","title":"Basic eigenmotion","text":"r = sim.output_writers[1].mem\nt = sim.output_writers[1].t\n\nx = getindex.(r, 1)\ny = getindex.(r, 2)\nz = getindex.(r, 3)\n\nplot(t, z)","category":"page"},{"location":"generated/examples/basic_eigenmotion/","page":"Basic eigenmotion","title":"Basic eigenmotion","text":"","category":"page"},{"location":"generated/examples/basic_eigenmotion/","page":"Basic eigenmotion","title":"Basic eigenmotion","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/validation/resistor_noiseless/#Ion-detection:-Noiseless-resistor","page":"Noiseless Resistor","title":"Ion detection: Noiseless resistor","text":"","category":"section"},{"location":"generated/validation/resistor_noiseless/","page":"Noiseless Resistor","title":"Noiseless Resistor","text":"In this validation study, the damping of a single ion stored inside a Penning trap when a resistor is connected to one of the electrodes is simulated.","category":"page"},{"location":"generated/validation/resistor_noiseless/","page":"Noiseless Resistor","title":"Noiseless Resistor","text":"The theoretical damping time constant is given by","category":"page"},{"location":"generated/validation/resistor_noiseless/","page":"Noiseless Resistor","title":"Noiseless Resistor","text":"d = fracq^2R2mD_textnormaleff^2","category":"page"},{"location":"generated/validation/resistor_noiseless/","page":"Noiseless Resistor","title":"Noiseless Resistor","text":"to which we are going to compare the damping of the simulated axial motion against.","category":"page"},{"location":"generated/validation/resistor_noiseless/","page":"Noiseless Resistor","title":"Noiseless Resistor","text":"This validation study checks for","category":"page"},{"location":"generated/validation/resistor_noiseless/","page":"Noiseless Resistor","title":"Noiseless Resistor","text":"correct conversion between ion velocity and current induced onto electrode.\ncorrect implementation of effective electrode distance.\ncorrect conversion from induced image current to voltage on electrode within the circuit cosimulation.\ncorrect backaction force onto ion resulting from the voltage on the Penning trap electrode.","category":"page"},{"location":"generated/validation/resistor_noiseless/","page":"Noiseless Resistor","title":"Noiseless Resistor","text":"using Penning\nusing Plots\n\nconst OVERSAMPLING = 20;","category":"page"},{"location":"generated/validation/resistor_noiseless/#Trap-parameters","page":"Noiseless Resistor","title":"Trap parameters","text":"","category":"section"},{"location":"generated/validation/resistor_noiseless/","page":"Noiseless Resistor","title":"Noiseless Resistor","text":"In this simulation, only the axial motion is of interest, which is why the B_0 coefficient can be set to an arbitrary vakue","category":"page"},{"location":"generated/validation/resistor_noiseless/","page":"Noiseless Resistor","title":"Noiseless Resistor","text":"const Uâ‚€ = -50.0\nconst câ‚‚ = -14960.0\nconst Bâ‚€ = 7.0","category":"page"},{"location":"generated/validation/resistor_noiseless/#Effective-electrode-distance-D_\\textnormal{eff}-and-resistance-R","page":"Noiseless Resistor","title":"Effective electrode distance D_textnormaleff and resistance R","text":"","category":"section"},{"location":"generated/validation/resistor_noiseless/","page":"Noiseless Resistor","title":"Noiseless Resistor","text":"const D_eff = 5e-3\nconst R = 100e6\n\nion = Ion(187, 30)\nomega_c, omega_p, omega_m, omega_z = calc_eigenfrequencies(Uâ‚€, câ‚‚, Bâ‚€, ion.q, ion.m)","category":"page"},{"location":"generated/validation/resistor_noiseless/#Theoretical-damping-time-constant","page":"Noiseless Resistor","title":"Theoretical damping time constant","text":"","category":"section"},{"location":"generated/validation/resistor_noiseless/","page":"Noiseless Resistor","title":"Noiseless Resistor","text":"d_theory = ion.q^2*R/ion.m/D_eff^2 / 2\nprintln(\"Theoretical damping time constant: $(d_theory) 1/s\")","category":"page"},{"location":"generated/validation/resistor_noiseless/#Simulation-setup","page":"Noiseless Resistor","title":"Simulation setup","text":"","category":"section"},{"location":"generated/validation/resistor_noiseless/","page":"Noiseless Resistor","title":"Noiseless Resistor","text":"trap = Trap(\n    fields = (\n        IdealTrapField(Uâ‚€, câ‚‚, Bâ‚€),\n    ),\n    particles = (\n        ParticleCollection(ion, [[0, 0, 50e-6]], [[0, 0, 0]]),\n    ),\n    electrodes = (\n        AxialParallelPlateElectrode(D_eff),\n    )\n)\n\nsetup = Setup(\n    traps = (\n        trap,\n    ),\n    circuits = (\n        CircuitResistor(R, T=0.0),\n    ),\n    connections = (\n        Connection(trap=1, electrode=1, circuit=1, circuit_pin=1),\n    )\n)\n\nsim = Simulation(\n    setup,\n    dt=2*pi/omega_z/OVERSAMPLING,\n    output_writers=(\n        MemoryWriter(PositionComponentObservable(1, 1, 1, 3), IterationInterval(4)),\n    )\n)\n\nrun!(sim, run_until_time=1/d_theory)\n\nz = sim.output_writers[1].mem\nt = sim.output_writers[1].t\n\nplot(t*1e3, z*1e6, label=\"Simulation\")\n\nharminv_results = harminv(t, z, omega_z/2/pi-10e3, omega_z/2/pi+10e3)\n\nA = harminv_results[1].amp\nd = harminv_results[1].decay_const\nprintln(\"Simulated decay constant:   $(d) 1/s\")\n\ntheory = 2*A*exp.(-t*d_theory)\nplot!(t*1e3, theory*1e6, label=\"Theory\")\nxlabel!(\"\\$t\\$ / ms\")\nylabel!(\"Axial amplitude / Âµm\")\n\nannotate!(1/d_theory/2*1e3, 5, \"\\$d_\\\\textnormal{theo.}\\$ = $(d_theory) 1/s\")\nannotate!(1/d_theory/2*1e3, -5, \"\\$d_\\\\textnormal{sim.}\\$ = $(d) 1/s\")\n\nsavefig(joinpath(@__DIR__, \"resistor_noiseless.png\"))","category":"page"},{"location":"generated/validation/resistor_noiseless/#Results","page":"Noiseless Resistor","title":"Results","text":"","category":"section"},{"location":"generated/validation/resistor_noiseless/","page":"Noiseless Resistor","title":"Noiseless Resistor","text":"(Image: )","category":"page"},{"location":"generated/validation/resistor_noiseless/","page":"Noiseless Resistor","title":"Noiseless Resistor","text":"","category":"page"},{"location":"generated/validation/resistor_noiseless/","page":"Noiseless Resistor","title":"Noiseless Resistor","text":"This page was generated using Literate.jl.","category":"page"},{"location":"simulation_setup/traps/#Traps","page":"Traps","title":"Traps","text":"","category":"section"},{"location":"simulation_setup/traps/#Custom-traps","page":"Traps","title":"Custom traps","text":"","category":"section"},{"location":"simulation_setup/traps/","page":"Traps","title":"Traps","text":"You might want to simulate the effects of fluctuating trap potentials or drifting magnetic fields.","category":"page"},{"location":"getting_started/#Getting-started","page":"Getting Started","title":"Getting started","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This section covers the basics of installing Julia and Penning.jl, and then describes best practices when running setting up your environment. If you're new to Julia, we also recommend reading Julia's \"getting started\" page.","category":"page"},{"location":"getting_started/#Installation-instructions","page":"Getting Started","title":"Installation instructions","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Usually the hardest part of installing Penning.jl is installing Julia. You can first check if your system already has Julia installed. If that's not the case, installation is necessary and you can download Julia from its official website, where also you can find platform-specific installation instructions. Alternatively, you can also manually compile Julia from source code.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"With Julia installed, you can install Oceananigans with a single line of code within Julia itself: ] add Oceananigans.  However, best practices for Julia suggest a couple extra commands to ensure that each project has a separate and easily reproducible environment (we suggest that users read this page to get a better understanding of working with environments). Best practices when starting a new Oceananigans  project is to ","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Start with a empty directory (in this example called new_project).\nInside the empty directory, start Julia with the command julia --project.\nAccess the built-in package manager by pressing ] in the Julia command prompt.\nAdd the Oceananigans package with add Oceananigans.\nInstantiate/build all dependencies instantiate.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"To do so, open a Julia REPL from the terminal and then start the package manager by hitting ]. Then:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"(@v1.6) pkg> activate .\n  Activating new environment at `~/new_project/Project.toml`\n\n(new_project) pkg> add Oceananigans\n(new_project) pkg> instantiate","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"We recommend installing Oceananigans with this way (using the built-in Julia package manager), because this installs a stable, tagged release. Oceananigans.jl can be updated to the latest tagged release from the package manager by typing","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"(new_project) pkg> update Oceananigans","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"At this time, updating should be done with care, as Oceananigans is under rapid development and breaking  changes to the user API occur often. But if anything does happen, please open an issue on github! We're more than happy to help with getting your simulations up and running.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"compat: Julia 1.6 or newer\nThe latest version of Oceananigans requires at least Julia v1.6 to run. Installing Oceananigans with an older version of Julia will install an older version of Oceananigans (the latest version compatible with your version of Julia).","category":"page"},{"location":"getting_started/#Running-Oceananigans","page":"Getting Started","title":"Running Oceananigans","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Whenever you run Oceananigans for a project, it is recommended that you activate the project's environment first. This ensures that you will always use the package versions of you project and that any changes there will not affect other projects.. To activate the project's environment you either start Julia using julia --project or from Julia's package manager you call:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"(@v1.6) pkg> activate .\n  Activating new project at `~/new_project`\n\n(new_project) pkg>","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"For initial explorations and getting used to the code, you can enter the commands directly in the Julia REPL (which can be started with the command julia --project). The REPL is an interactive command-line tool (similar to Python's IPython) that has a searchable history, tab-completion, helpful keybindings, and many other features to help users interact with packages. If you already have a script, you can call julia --project my_oceananigans_script.jl from the terminal. This will execute all the commands in that script and subsequently close Julia. This is equivalent to opening the Julia REPL inside your project directory and typing each of those commands by hand (or simply calling include(\"my_oceananigans_script.jl\") in the REPL).","category":"page"},{"location":"output_writers/memory_writer/#Writing-to-memory","page":"Writing to memory","title":"Writing to memory","text":"","category":"section"},{"location":"output_writers/memory_writer/","page":"Writing to memory","title":"Writing to memory","text":"In many cases, it might be helpful to keep a \"history\" of certain variables of a simulation inside the main memory (RAM). This allows to perform data analysis in Julia right after finishing the simulation, without having to store the data in an intermediate file on disk (which might also slow down your simulation).","category":"page"},{"location":"output_writers/memory_writer/","page":"Writing to memory","title":"Writing to memory","text":"info: Info\nWhen executing long running simulations or storing big chunks of data per write-iteration, you might want to keep an eye on memory utilization.","category":"page"},{"location":"output_writers/memory_writer/#MemoryWriter","page":"Writing to memory","title":"MemoryWriter","text":"","category":"section"},{"location":"output_writers/memory_writer/","page":"Writing to memory","title":"Writing to memory","text":"MemoryWriter(::Function, ::Penning.OutputWriters.Utils.AbstractSchedule)","category":"page"},{"location":"output_writers/memory_writer/#PositionMemoryWriter","page":"Writing to memory","title":"PositionMemoryWriter","text":"","category":"section"},{"location":"output_writers/memory_writer/","page":"Writing to memory","title":"Writing to memory","text":"PositionMemoryWriter(::Symbol, ::Symbol, ::Penning.Utils.AbstractSchedule)","category":"page"},{"location":"output_writers/memory_writer/#CircuitMemoryWriter","page":"Writing to memory","title":"CircuitMemoryWriter","text":"","category":"section"},{"location":"output_writers/memory_writer/","page":"Writing to memory","title":"Writing to memory","text":"CircuitMemoryWriter(observable, ::Penning.Utils.AbstractSchedule)","category":"page"},{"location":"simulation_setup/interactions/#Particle-interactions","page":"Particle interactions","title":"Particle interactions","text":"","category":"section"},{"location":"utils/schedules/#Schedules","page":"Schedules","title":"Schedules","text":"","category":"section"},{"location":"utils/schedules/","page":"Schedules","title":"Schedules","text":"Various parts of Penning.jl (e.g. Output writers or callbacks) need to execute certain actions at specific time intervals. For that, a family of schedules were introduced that cover a variety of basic scheduling tasks:","category":"page"},{"location":"utils/schedules/","page":"Schedules","title":"Schedules","text":"TimeInterval\nAlignedTimeInterval\nIterationInterval\nWallTimeInterval\nSpecifiedTimes","category":"page"},{"location":"utils/schedules/","page":"Schedules","title":"Schedules","text":"Additionally, there are \"composit schedules\", that link different schedules together, to build complex time dependencies:","category":"page"},{"location":"utils/schedules/","page":"Schedules","title":"Schedules","text":"ConsecutiveIterations\nAndSchedule\nOrSchedule","category":"page"},{"location":"utils/schedules/#TimeInterval","page":"Schedules","title":"TimeInterval","text":"","category":"section"},{"location":"utils/schedules/","page":"Schedules","title":"Schedules","text":"TimeInterval(::Number)","category":"page"},{"location":"utils/schedules/#Penning.Utils.TimeInterval-Tuple{Number}","page":"Schedules","title":"Penning.Utils.TimeInterval","text":"TimeInterval(interval)\n\nReturns a callable TimeInterval that schedules periodic output or diagnostic evaluation on a interval of simulation time, as kept by model.clock. Pay attention that this schedule might not actuate in equidistant intervals if the passed interval is not properly  aligned with the simulation time step.  See AlignedTimeInterval for an aligned version.\n\n\n\n\n\n","category":"method"},{"location":"utils/schedules/#AlignedTimeInterval","page":"Schedules","title":"AlignedTimeInterval","text":"","category":"section"},{"location":"utils/schedules/","page":"Schedules","title":"Schedules","text":"AlignedTimeInterval(::Number, ::Number)","category":"page"},{"location":"utils/schedules/#Penning.Utils.AlignedTimeInterval-Tuple{Number, Number}","page":"Schedules","title":"Penning.Utils.AlignedTimeInterval","text":"AlignedTimeInterval(interval, dt)\n\nSimilar to TimeInterval, but aligns the interval to multiples of dt. Actually, this function returns an IterationInterval in order to guarantee for  exactly equidistant \"actuation events\".\n\n\n\n\n\n","category":"method"},{"location":"utils/schedules/#IterationInterval","page":"Schedules","title":"IterationInterval","text":"","category":"section"},{"location":"utils/schedules/","page":"Schedules","title":"Schedules","text":"IterationInterval(interval)","category":"page"},{"location":"utils/schedules/#Penning.Utils.IterationInterval-Tuple{Any}","page":"Schedules","title":"Penning.Utils.IterationInterval","text":"IterationInterval(interval; offset=0)\n\nReturns a callable IterationInterval that \"actuates\" whenever the simulation iteration (modified by offset) is a multiple of interval. For example, \n\nIterationInterval(100) actuates at iterations [100, 200, 300, ...].\nIterationInterval(100, offset=-1) actuates at iterations [99, 199, 299, ...].\n\n\n\n\n\n","category":"method"},{"location":"utils/schedules/#WallTimeInterval","page":"Schedules","title":"WallTimeInterval","text":"","category":"section"},{"location":"utils/schedules/","page":"Schedules","title":"Schedules","text":"WallTimeInterval(interval)","category":"page"},{"location":"utils/schedules/#Penning.Utils.WallTimeInterval-Tuple{Any}","page":"Schedules","title":"Penning.Utils.WallTimeInterval","text":"WallTimeInterval(interval; start_time = time_ns() * 1e-9)\n\nReturns a callable WallTimeInterval that actuates on a interval of \"wall time\" while a simulation runs, in units of seconds. The \"wall time\" is the actual real world time in seconds, as kept by an actual or hypothetical clock hanging on your wall. The keyword argument start_time can be used to specify a starting wall time other than the moment WallTimeInterval is constructed.\n\n\n\n\n\n","category":"method"},{"location":"utils/schedules/#SpecifiedTimes","page":"Schedules","title":"SpecifiedTimes","text":"","category":"section"},{"location":"utils/schedules/","page":"Schedules","title":"Schedules","text":"SpecifiedTimes(::Vararg{<:Number})","category":"page"},{"location":"utils/schedules/#Penning.Utils.SpecifiedTimes-Tuple{Vararg{Number}}","page":"Schedules","title":"Penning.Utils.SpecifiedTimes","text":"SpecifiedTimes(times)\n\nReturns a callable SpecifiedTimes that actuates at predefined simulation times. Pass times either by individual arguments SpecifiedTimes(0.0, 3.14, 8.9) or as a list SpecifiedTimes([0.0, 3.14, 8.9])\n\n\n\n\n\n","category":"method"},{"location":"utils/schedules/#ConsecutiveIterations","page":"Schedules","title":"ConsecutiveIterations","text":"","category":"section"},{"location":"utils/schedules/","page":"Schedules","title":"Schedules","text":"ConsecutiveIterations(parent_schedule)","category":"page"},{"location":"utils/schedules/#AndSchedule","page":"Schedules","title":"AndSchedule","text":"","category":"section"},{"location":"utils/schedules/","page":"Schedules","title":"Schedules","text":"AndSchedule(schedules...)","category":"page"},{"location":"utils/schedules/#Penning.Utils.AndSchedule-Tuple","page":"Schedules","title":"Penning.Utils.AndSchedule","text":"AndSchedule(child_schedule_1, child_schedule_2, other_child_schedules...)\n\nReturn a schedule that actuates when all child_schedules actuate.\n\n\n\n\n\n","category":"method"},{"location":"utils/schedules/#OrSchedule","page":"Schedules","title":"OrSchedule","text":"","category":"section"},{"location":"utils/schedules/","page":"Schedules","title":"Schedules","text":"OrSchedule(schedules...)","category":"page"},{"location":"utils/schedules/#Penning.Utils.OrSchedule-Tuple","page":"Schedules","title":"Penning.Utils.OrSchedule","text":"OrSchedule(child_schedule_1, child_schedule_2, other_child_schedules...)\n\nReturn a schedule that actuates when any of the child_schedules actuates.\n\n\n\n\n\n","category":"method"},{"location":"output_writers/overview/#Output-writers-overview","page":"Overview","title":"Output writers overview","text":"","category":"section"},{"location":"output_writers/overview/","page":"Overview","title":"Overview","text":"Penning.jl provides various output mechanisms that can be readily used to save the state or derived variables of a simulation.","category":"page"},{"location":"output_writers/overview/#Schedules","page":"Overview","title":"Schedules","text":"","category":"section"},{"location":"output_writers/overview/","page":"Overview","title":"Overview","text":"All output writers accept a schedule argument, which specifies at which point in time the output should be saved. The available schedule-implementations are defined in the Schedules documentation.","category":"page"},{"location":"output_writers/overview/#Registering-output-writers","page":"Overview","title":"Registering output writers","text":"","category":"section"},{"location":"output_writers/overview/","page":"Overview","title":"Overview","text":"In order for the output writers to be executed during the simulation, they must be registered to the Simulation instance:","category":"page"},{"location":"output_writers/overview/","page":"Overview","title":"Overview","text":"sim = Simulation(...)\nsim.output_writers[:electron_position] = PositionMemoryWriter(...)","category":"page"},{"location":"output_writers/overview/","page":"Overview","title":"Overview","text":"In this example the output writer was registered under the name/symbol :electron_position.","category":"page"},{"location":"simulation/integrators/#Particle-Integrators","page":"Particle integrators","title":"Particle Integrators","text":"","category":"section"},{"location":"simulation/integrators/","page":"Particle integrators","title":"Particle integrators","text":"Standard ODE solvers (e.g. 4th order Runge Kutta) add a small numerical error at each timestep, which, over the long run, leads to a drift of the total energy inside the system. This is particularly undesirable for particle simulations, as they are usually being run for many timesteps and would therefore be guaranteed to end up with unphysical particle trajectories. We therefore have to carefully choose a particle integration algorithm that conserves energy, e.g. one of the family of symplectic integrators. A very simple aproach for symplectic integration is the leap-frog scheme, in which particle positions and velocities are calculated in a time-staggered manner.","category":"page"},{"location":"simulation/integrators/#Boris-Method","page":"Particle integrators","title":"Boris Method","text":"","category":"section"},{"location":"simulation/integrators/#Modified-Boris-Method-(DEFAULT)","page":"Particle integrators","title":"Modified Boris Method (DEFAULT)","text":"","category":"section"},{"location":"simulation/integrators/","page":"Particle integrators","title":"Particle integrators","text":"While the Boris method is good at preserving conserved quantities, it introduces a phase error on the radial modes. However, there is a simple modification[1], that fixes the phase error in all orders for static magnetic fields. For spatially or time-varying magnetic fields this is not necessarily true, which has to be further evaluated. The modified Boris pusher is available as ModifiedBorisPusher in Penning and is used by default if no particle pusher is explicitly specified.","category":"page"},{"location":"#Penning.jl","page":"Home","title":"Penning.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Flexible and extensible Julia framework for simulating the motion of particles in Penning traps.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Penning.jl is a flexible and extensible simulation framework written in Julia that uses a symplectic time stepper to solve for the motion of charged particles in a Penning trap and features an integrated circuit simulator that is coupled to the Penning trap simulation. It scales from simple single-particle systems up to complex N-body problems, possibly in multiple interconnected Penning-traps. Penning.jl comes with many builtin features like a variety of excitation fields, including dipolar fields, plane waves and cavity modes, support for different damping mechanisms, noise injection and more. The integrated circuit simulator can be used to model the coupling of particles to a user-defined external circuit, most commonly an RLC tank circuit.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The interface was designed to make Penning.jl as friendly and intuitive to use as possible. An in-built collection of diagnostics and file-writers enables post-processing directly in Julia or 3rd party applications.","category":"page"}]
}
